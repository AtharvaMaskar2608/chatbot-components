import os
import json


from typing import List, Dict

# Importing Assembly AI libraries 
import assemblyai as aai

from dotenv import load_dotenv
import requests

load_dotenv()
from openai import OpenAI

client = OpenAI()

def preprocess_speaker_transcript(transcript: str, agentName: str) -> str:
    """
    Description:
        - This function takes the script which is in the format of Speaker A & Speaker B and replaces them with actual names of the speaker. 

    parameters:
        - transcript (str): Call transcript
        - agentName (str): Name of the agent

    returns:   
        - processed_transcript (str): Processed trancript will be in the following format, AgentName & Customer  
    """

    system_prompt = f"You are a transcript which is in the following format: <Speaker A>: <Text> <Speaker B>: <Text>. From the transcript you have to identify who the agent is. Name of the company agent is: {agentName}. Understand the context and do not assume anything from any speaker, purely work on the transcript. Return `Speaker A` if you think speaker A is the agent, or return `Speaker B` if you think the speaker B is the agent. Strictly reply in `Speaker A` or `Speaker B` only always without any explanation or additional text."

    user_prompt = f"For the given transcript: {transcript}, return `Speaker A` if you think Speaker A is the agent and Speaker B is the customer. Return `Speaker B` if you think speaker B is the agent and the Speaker A is the customer."

    completion = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ]
    )

    if completion.choices[0].message.content == "Speaker A":
        processed_transcripts = pre_process_text(transcript=transcript, agentName=agentName, agentTag="Speaker A", customerTag="Speaker B")
    elif completion.choices[0].message.content == "Speaker B":
        processed_transcripts = pre_process_text(transcript=transcript, agentName=agentName, agentTag="Speaker B", customerTag="Speaker A")

    return processed_transcripts         

def pre_process_text(transcript: str, agentName: str, agentTag: str, customerTag: str)  -> str:
    """
    Description:
        - This function returns the processed transcripts with names. 
    
    parameters:
        - transcript (str): Call transcript
        - agentName (str): Name of the agent
        - agentTag (str): What to replace the agent name with Speaker A or B
        - customerTag (str): What to replace customer with
    returns:
        - processed_transcript (str): Processed transcripts. 
    """

    # 1. Replacing agentTag with agentName

    processed_transcripts = transcript.replace(agentTag, f"Agent {agentName}: ")


    # 2. Replacing customer Tag with Customer
    processed_transcripts = processed_transcripts.replace(customerTag, "Customer")

    return processed_transcripts


def transcribe_audio(audio_file_path: str) -> List[Dict[str, str]]:
    """
    Description:
        - This function uses the assembly AI API to take an audio file and transcribe it. 

    parameters:
        - audio_file_path (str): path of the audio file 
    
    returns:
        - transcripts (arr): Array of dictionary of transcripts
    """

    try:
        aai.settings.api_key = os.getenv("ASSEMBLY_AI_API_KEY")

        config = aai.TranscriptionConfig(language_code='hi', speaker_labels=True, speakers_expected=2, punctuate=True)

        transcriber = aai.Transcriber()
        transcript = transcriber.transcribe(
            audio_file_path,
            config=config
        )

        return transcript.utterances

    except Exception as e:
        print("Problem transcribing audio: ", e)


def get_audio_urls(folder_path: str):
    """
    Description:
        - This function returns the parth of all the files in a folder
    parameters:
        - folder_path (str): Path of the folder

    returns:
        - audio_urls (arr): Array of all audio urls in a folder        
    """

    # List to store file paths
    file_paths = []

    for root, dirs, files in os.walk(folder_path):
        for file in files:
            file_paths.append(os.path.join(root, file))

    return file_paths

def generate_sumary(transcript: str, agentName: str) -> str:
    """
    Description: This function generates summary for a given transcript. 
    parameters: 
        - transcript (str): Call transcript
    returns:
        - summary (str): Summary generated by open AI
    """

    system_prompt = f"""You are a professional Indian hindi sales call analyzer. Your work is to summarize a call and cover the following topics. Every call is an incoming call from the client to the company agent named {agentName}. In your summary cover the following .1. Who called whom. 2. Problem of the client 3. What did the Agent do to solve the problem. 3. Did he solve it properly from his end. On the above paramteres generate a detailed long summary of the call in English. Do not do both at once. Also clearly mention if:
    - Agent was rude, mean or disrespectful towards the customer. 
    - Agent left the customer on hold or waiting too long. 

    -OR
    - If there were a few problems from the agent's side, where the customer was being mean and the agent had to be neutral or a bit mean.
    - If the agent tried to solve the problem, but it was not resolved till the end. 

    - If the agent was very polite and understanding towards the customer, but still the customer seemed frustrated. Despite of all this the agent handled it with empathy and helped the customer. 
    - If the call had a few major problems but got solved at the end and the agent assisted the customer eventually resolving the query.
    - Or the call was smooth with few problems or no problems at all. 
    - If the agent tried to solve the problem, but it was not resolved till the end but the agent gave a solution which the user did not think of or hadn't tried and was gonna try after the call.
    """

    user_prompt = f"{transcript}, for the given transcript generate a summary. "

    completion = client.chat.completions.create(
        temperature=0,
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ]
    )

    return completion.choices[0].message.content


folder_path_marking_0 = '/home/choice/Desktop/chatbot-components/script/audio calls/recordings/0'
folder_path_marking_2 = '/home/choice/Desktop/chatbot-components/script/audio calls/recordings/2'

audio_calls_marking_0 = get_audio_urls(folder_path_marking_0)
audio_calls_marking_2 = get_audio_urls(folder_path_marking_2)

summaries_0 = []

# # Create trnascripts for 0
# for i, audio_call in enumerate(audio_calls_marking_0):
#     transcripts = transcribe_audio(audio_file_path=audio_call)
#     audio_transcripts = ""

#     for transcript in transcripts:
#         audio_transcripts += f"Speaker {transcript.speaker}: {transcript.text}\n"

#     audio_transcripts = preprocess_speaker_transcript(audio_transcripts, "")
#     summary = generate_sumary(transcript=audio_transcripts, agentName="")

#     summaries_0.append(summary)

#     print("Completed for ranking 0", i+1)

# with open ("call_rating_0.json", 'w') as jsonFile:
#     json.dump(summaries_0, jsonFile, indent=4)

summaries_2 = []
# Create trnascripts for 2
for i, audio_call in enumerate(audio_calls_marking_2):
    transcripts = transcribe_audio(audio_file_path=audio_call)

    audio_transcripts = ""

    for transcript in transcripts:
        audio_transcripts += f"Speaker {transcript.speaker}: {transcript.text}\n"
    
    audio_transcripts = preprocess_speaker_transcript(audio_transcripts, "")

    summary = generate_sumary(transcript=audio_transcripts, agentName="")

    summaries_2.append(summary)

    print("Completed for ranking 2 ", i+1)

with open ("call_rating_2.json", 'w') as jsonFile:
    json.dump(summaries_2, jsonFile, indent=4)    